var documenterSearchIndex = {"docs":
[{"location":"iminuit/#Functions-in-iminuit","page":"iminuit functions","title":"Functions in iminuit","text":"","category":"section"},{"location":"iminuit/#Minuit","page":"iminuit functions","title":"Minuit","text":"","category":"section"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"Minuit(fcn; kwds...)::Fit\nMinuit(fcn, start; kwds...)::ArrayFit","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"Wrapper of the iminuit function Minuit.  fcn is the function to be optimized.  start: an array/tuple of the starting values of the parameters.  kwds is the list of keywrod arguments of Minuit. For more information, refer to the iminuit manual.  The Fit one, for which fcn takes individual parameters as variables,  is generally  faster than the ArrayFit one, for which fcn takes array parameters.","category":"page"},{"location":"iminuit/#migrad,-hesse,-minos","page":"iminuit functions","title":"migrad, hesse, minos","text":"","category":"section"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"migrad, minos, hesse, matrix","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"wrappers of iminuit.Minuit.migrad, iminuit.Minuit.minos, iminuit.Minuit.hesse, iminuit.Minuit.matrix.","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"migrad(f::AbstractFit; ncall = 1000, resume = true, nsplit = 1, precision = nothing)","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"minimizing using MIGRAD. Further information can be found by","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:migrad, :minos, :hesse, :matrix, :args] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc migrad","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"hesse(f::AbstractFit; maxcall = 0)","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"run HESSE to compute parabolic errors.","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:migrad, :minos, :hesse, :matrix, :args] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc hesse","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"minos(f::AbstractFit; var = nothing, sigma = 1, maxcall = 0)","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"run MINOS to compute asymmetric errors taking into account correlation and nonlinearity","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:migrad, :minos, :hesse, :matrix, :args] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc minos","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"For a fit f, ","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"args(f::AbstractFit)","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"return the parameter values from fit f.","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"matrix(f::AbstractFit; kws...) ","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"return error or correlation matrix (set the keyword correlation = true).","category":"page"},{"location":"iminuit/#Some-other-useful-iminuit-functions","page":"iminuit functions","title":"Some other useful iminuit functions","text":"","category":"section"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"For a fit f, ","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"f.contour(par1, par2; kws)\nf.mncontour(par1, par2; kws)\nf.mnprofile(par1; kws)","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:contour] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc contour","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:mncontour] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc mncontour","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"using IMinuit # hide\nmMinuit = iminuit.Minuit # hide\nfor f in [:mnprofile] # hide\n    sf = string(f) # hide\n    @eval @doc LazyHelp(mMinuit, $sf)  function $f(ars...; kws...) #function $f(args...; kws...) # hide\n       if !hasproperty(mMinuit, $sf) # hide\n            error(\"iminuit \", version, \" does not have iminuit.Minuit\", $sf) # hide\n        end # hide\n        return pycall(mMinuit.$sf, PyAny, ars...; kws...) # hide\n    end # hide\nend # hide\n@doc mnprofile","category":"page"},{"location":"iminuit/","page":"iminuit functions","title":"iminuit functions","text":"Other iminuit functions can also be used, like f.draw_contour(par1, par2; kws) and f.draw_mncontour(par1, par2; kws).","category":"page"},{"location":"modelfit/#chisq-and-model_fit","page":"chisq and model_fit","title":"chisq and model_fit","text":"","category":"section"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"chisq(dist::Function, data, par; fitrange = ())","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"defines the χ² function: fun the function to be fitted to the data given by data. The parameters are collected into par, given as an array or a tuple.","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"dist should be defined as dist(x, par).\ndata can be either given as the Data type, or of the form (xdata, ydata [, err]).","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"If no err is given explicitly, the errors are assumed to be 1 for all data points.","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"fitrange: default to the whole data set; may given as, e.g., 2:10,","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"which means only fitting to the 2nd to the 10th data points.","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"If there is only one distribution to be fitted, then one can simply use:","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"model_fit(model::Function, data::Data, start_values; kws...)\n@model_fit model data start_values kws...","category":"page"},{"location":"modelfit/","page":"chisq and model_fit","title":"chisq and model_fit","text":"the returning type is ArrayFit, which can be passed to migrad, minos etc. to perform the fit and error analysis.  model is the function to be fitted to data; it should be of the form model(x, params) with params given either as an array or a tuple.","category":"page"},{"location":"data/#Useful-functions","page":"Data and plot macros","title":"Useful functions","text":"","category":"section"},{"location":"data/","page":"Data and plot macros","title":"Data and plot macros","text":"Data(x::T, y::T, err::T) where {T<:Vector{Real}}\nData(df::DataFrame)","category":"page"},{"location":"data/","page":"Data and plot macros","title":"Data and plot macros","text":"Fields: x, y, err, ndata. This defines a type for data with three columns:x, y, err;\nndata is the number of data rows, automatically counted.\nDifferent Data sets can be concatenated as vat(dat1, dat2, dat3).\ngetindex defined for Data, e.g., data[1:10] gives the first 10 points in data.","category":"page"},{"location":"data/","page":"Data and plot macros","title":"Data and plot macros","text":"@plt_data(data, kws...)\n@plt_data!(data, kws...)\n@plt_best(dist, fit, data, kws...)\n@plt_best!(dist, fit, data, kws...)","category":"page"},{"location":"data/","page":"Data and plot macros","title":"Data and plot macros","text":"convenient macros for plotting the data, and a comparison of the best-fit curve with the data (needs using Plots). kwds... in @plt_data adjusts settings of the scatter plot, and that in @plt_best adjusts settings of the best-fit curve plot. For @plt_best and @plt_best!, the ordering of dist, fit, and data does not matter, i.e., @plt_best dist fit data,  @plt_best fit dist data, @plt_best fit data dist and so on all work.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = IMinuit","category":"page"},{"location":"#IMinuit.jl","page":"Home","title":"IMinuit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia wrapper of the Python package iminuit, which is the interface to the C++ MINUIT2, widely used in fitting in the high-energy physics community.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [IMinuit]","category":"page"},{"location":"#IMinuit.ArrayFit","page":"Home","title":"IMinuit.ArrayFit","text":"ArrayFit <: AbstractFit\n\nstruct for fit with parameters collected in an Array.\n\n\n\n\n\n","category":"type"},{"location":"#IMinuit.Data","page":"Home","title":"IMinuit.Data","text":"Data(x::T, y::T, err::T) where {T<:Vector{Real}}\nData(df::DataFrame)\n\nFields: x, y, err, ndata\n\nThis defines a type for data with three columns:x, y, err; ndata is the number of data rows. Different Data sets can be concatenated as vat(dat1, dat2, dat3).\n\nOnly symmetric errors (of y) are supported.\n\n\n\n\n\n","category":"type"},{"location":"#IMinuit.Fit","page":"Home","title":"IMinuit.Fit","text":"Fit <: AbstractFit\n\nstruct for fit with individual parameters.\n\n\n\n\n\n","category":"type"},{"location":"#IMinuit.Minuit-Tuple{Any}","page":"Home","title":"IMinuit.Minuit","text":"Minuit(fcn; kwds...)\nMinuit(fcn, start; kwds...)\n\nWrapper of the iminuit function Minuit.\n\nfcn is the function to be optimized.\nstart: an array/tuple of the starting values of the parameters.\nkwds is the list of keywrod arguments of Minuit. For more information, refer to the iminuit manual.\n\nExample:\n\nfit = Minuit(fcn, [1, 0]; name = [\"a\", \"b\"], error = 0.1*ones(2), \n            fix_a = true, limit_b = (0, 50) )\nmigrad(fit)\n\nwhere the parameters are collected in an array par which is the argument of fcn(par). In this case, one can use external code (e.g., using ForwardDiff: gradient) to compute the gradient as gradfun(par) = gradient(fcn, par), and include grad = gradfun as a keyword argument.\n\nIf fcn is defined as fcn(a, b), then the starting values need to be set as Minuit(fcn, a = 1, b = 0).\n\nFrom iminuit:\n\nMinuit(fcn, throw_nan=False, pedantic=True, forced_parameters=None, print_level=0,          errordef=None, grad=None, use_array_call=False, **kwds)\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.chisq-Tuple{Function,Data,Any}","page":"Home","title":"IMinuit.chisq","text":"chisq(dist::Function, data, par; fitrange = ())\n\ndefines the chi^2 function: fun the function to be fitted to the data given by data. The parameters are collected into par, given as an array or a tuple.\n\ndata can be either given as the Data type, or of the form (xdata, ydata [, err]).\n\nIf no err is given explicitly, the errors are assumed to be 1 for all data points.\n\nfitrange: default to the whole data set; may given as, e.g., 2:10,\n\nwhich means only fitting to the 2nd to the 10th data points.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.contour_df-Tuple{AbstractFit,Any}","page":"Home","title":"IMinuit.contour_df","text":"contour_df(fit::AbstractFit, χsq; npts=20, limits=true, sigma = 1.0)\n\nparameters in the form of a dataframe.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.contour_df_given_parameter-Union{Tuple{T}, Tuple{AbstractFit,Any,T,Any}} where T<:Union{String, Symbol}","page":"Home","title":"IMinuit.contour_df_given_parameter","text":"contour_df_given_parameter(fit::AbstractFit, χsq, para::T, range; limits = true) where {T <: Union{Symbol, String}}\n\nreturn parameter sets in one sigma for a given parameter constrained in a range as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.contour_df_samples-Tuple{AbstractFit,Any,Any,Any}","page":"Home","title":"IMinuit.contour_df_samples","text":"contour_df_samples(fit::AbstractFit, χsq, paras, ranges; nsamples = 100, MNbounds=true)\n\ngives  1σ parameter sets as a DataFrame for given parameters constrained in ranges:\n\nif paras is a single parameter, then take equally spaced nsamples in ranges given in the form of (min, max);\nif paras contain more parameters, then paras should be of the form (:para1, :para2), ranges should be of the form ((min1, max1), (min2, max2));\nparas can be more than 2. Values for the parameters given in paras are randomly sampled in the given ranges.\nis MNbounds is true, then constrain the parameters in the range provided by MINOS no matter whether that is valid or not (to be improved by checking the validity)\nif igrad is true, then use ForwardDiff.gradient to compute the gradient\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.func_argnames-Tuple{Function}","page":"Home","title":"IMinuit.func_argnames","text":"func_argnames(f::Function)\n\nExtracting the argument names of a function as an array.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.get_contours-Tuple{Fit,Any,Array{Int64,1}}","page":"Home","title":"IMinuit.get_contours","text":"get_contours(fit::AbstractFit, χsq, parameters_combination::Vector{Int}; npts::Int=20, limits=true, sigma = 1.0)\n\nFor a given fit fit and the chi^2 function χsq, gives an array of parameter arrays, with each array corresponding to a set of parameters obtained from calculating the MINOS 1σ contour (try to find npts points in the contour) for the two parameters in parameters_combination.\n\nparameters_combination is an Int array of the numbers of that two parameters, e.g. it is [1, 2] for the first two parameters and [2, 3] or the second and third parameters.\n\nIf limits is true, then fix one parameter to its bounds from MINOS of the best fit and get the values for the other parameters; this runs over all parameters.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.get_contours_all-Tuple{AbstractFit,Any}","page":"Home","title":"IMinuit.get_contours_all","text":"get_contours_all(fit::AbstractFit, χsq; npts=20, limits=true, sigma = 1.0)\n\nFor a given fit fit and the chi^2 function χsq, gives a list of parameters sets which are at the edge of 1σ MINOS contours for all combinations of varying parameters. The case of limits being true runs only once.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.get_contours_given_parameter-Union{Tuple{T}, Tuple{ArrayFit,Any,T,Any}} where T<:Union{String, Symbol}","page":"Home","title":"IMinuit.get_contours_given_parameter","text":"get_contours_given_parameter(fit::ArrayFit, χsq, para::T, range) where {T <: Union{Symbol, String}}\n\ngives parameter sets in one sigma for a given parameter constrained in a range. If no user-defined names have been given to the parameters, para is then \"x0\" or :x0 for the 1st parameter, \"x1\" or :x1 for the 2nd parameter, ...\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.get_contours_given_parameter-Union{Tuple{T}, Tuple{Fit,Any,T,Any}} where T<:Union{String, Symbol}","page":"Home","title":"IMinuit.get_contours_given_parameter","text":"get_contours_given_parameter(fit::Fit, χsq, para::T, range) where {T <: Union{Symbol, String}}\n\ngives parameter sets in one sigma for a given parameter constrained in a range.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.get_contours_samples-Tuple{Fit,Any,Any,Any}","page":"Home","title":"IMinuit.get_contours_samples","text":"get_contours_samples(fit::AbstractFit, χsq, paras, ranges; nsamples = 100, MNbounds = true)\n\nreturn 1σ parameter sets as an Array (the latter returns a DataFrame) for given parameters constrained in ranges:\n\nif paras is a single parameter, then take equally spaced nsamples in ranges given in the form of (min, max);\nif paras contain more (geq 2) parameters, then paras should be of the form (:para1, :para2), ranges should be of the form ((min1, max1), (min2, max2)),\n\nand values for the parameters given in paras are randomly sampled in the given ranges;\n\nif MNbounds is true, then constrain the parameters in the range provided by MINOS no matter whether that is valid or not (to be improved by checking the validity)\nif igrad is true, then use ForwardDiff.gradient to compute the gradient.\nFor using array parameters, if no user-defined names have been given to the parameters,\n\nparas should be given such that \"x0\" or :x0 for the 1st parameter, \"x1\" or :x1 for the 2nd parameter, ...\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.method_argnames-Tuple{Method}","page":"Home","title":"IMinuit.method_argnames","text":"method_argnames(m::Method)\n\nExtracting the argument names of a method as an array.\nModified from [`methodshow.jl`](https://github.com/JuliaLang/julia/blob/master/base/methodshow.jl) (`Vector{Any}`` changed to `Vector{Symbol}`)\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.model_fit-Tuple{Function,Data,Any}","page":"Home","title":"IMinuit.model_fit","text":"model_fit(model::Function, data::Data, start_values; kws...)\n\nconvenient wrapper, the returning stype is ArrayFit, which can be passed to migrad, minos etc.\n\nmodel is the function to be fitted to data; it should be of the form\n\nmodel(x, params) with params given either as an array or a tuple.\n\n\n\n\n\n","category":"method"},{"location":"#IMinuit.@model_fit-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Home","title":"IMinuit.@model_fit","text":"@model_fit model data start_values kws...\n\nconvenient wrapper, the returning stype is ArrayFit, which can be passed to migrad, minos etc.\n\nmodel is the function to be fitted to data; it should be of the form\n\nmodel(x, params) with params given either as an array or a tuple.\n\n\n\n\n\n","category":"macro"},{"location":"#IMinuit.@plt_best-Tuple{Any,Any,Any,Vararg{Any,N} where N}","page":"Home","title":"IMinuit.@plt_best","text":"@plt_best(dist, fit, data, kws...)\n@plt_best!(dist, fit, data, kws...)\n\nA convenient macro for comparing the best-fit result with the data; all combinations of keyword settings for plot in Plots can be used for the optional arguments kws... The ordering of dist, fit, and data does not matter.\n\n\n\n\n\n","category":"macro"},{"location":"#IMinuit.@plt_data-Tuple{Any,Vararg{Any,N} where N}","page":"Home","title":"IMinuit.@plt_data","text":"@plt_data(data, kws...)\n@plt_data!(data, kws...)\n\nConvenient mascros to make an errorbar plot of the data; all combinations of keyword settings for scatter in Plots can be used for the optional arguments kws...\n\n\n\n\n\n","category":"macro"},{"location":"contour/#Functions-for-error-analysis","page":"Error analysis","title":"Functions for error analysis","text":"","category":"section"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"There are functions in iminuit (MINUIT) to analyze parameter errors. Suppose we have an AbstractFit object fit, then one can use functions like fit.draw_contour(:par1, :par2), fit.draw_mncontour(:par1, :par2) etc., see the iminit documentation.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"The following extra functions could also be useful to get a set of parameters for error analysis if the model is highly nonlinear in the parameters.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"get_contours(fit::AbstractFit, χsq, parameters_combination::Vector{Int}; npts::Int=20, limits=true, sigma = 1.0)","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"For a given fit fit and the χ² function χsq, gives a list of parameter arrays, with each array corresponding to a set of parameters obtained from calculating the MINOS 1σ contour (try to find npts points in the contour) for the two parameters in parameters_combination.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"parameters_combination is an Int array of the numbers of that two parameters, e.g. it is [1, 2] for the first two parameters and [2, 3] or the second and third parameters.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"If limits is true, then fix one parameter to its bounds from MINOS of the best fit and get the values for the other parameters using MIGRAD; this runs over all parameters.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"get_contours_all(fit::AbstractFit, χsq; npts=20, limits=true, sigma = 1.0)","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"For a given fit fit and the χ² function χsq, gives a list of parameters sets which are at the edge of 1σ MINOS contours for all combinations of varying parameters. The case of limits being true runs only once.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"contour_df(fit::AbstractFit, χsq; npts=20, limits=true, sigma = 1.0) returns such parameters in the form of a DataFrame.","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"get_contours_given_parameter(fit::AbstractFit, χsq, para::T, range) where {T <: Union{Symbol, String}}\ncontour_df_given_parameter(fit::AbstractFit, χsq, para::T, range; limits = true) where {T <: Union{Symbol, String}}","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"give parameter sets in 1σ for a given parameter constrained in a range (the latter returns a DataFrame).","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"For using array parameters, if no user-defined names have been given to the parameters, paras should be given such that \"x0\" or :x0 for the 1st parameter, \"x1\" or :x1 for the 2nd parameter (default names in iminuit), ...","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"get_contours_samples(fit::AbstractFit, χsq, paras, ranges; nsamples = 100, MNbounds = true)\ncontour_df_samples(fit::AbstractFit, χsq, paras, ranges; nsamples = 100, MNbounds=true)","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"gives 1σ parameter sets as an Array (the latter returns a DataFrame) for given parameters constrained in ranges:","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"if paras is a single parameter, then take equally spaced nsamples in ranges given in the form of (min, max);\nif paras contain more (≧2) parameters, then paras should be of the form (:para1, :para2), ranges should be of the form ((min1, max1), (min2, max2)),","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"and values for the parameters given in paras are randomly sampled in the given ranges;","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"if MNbounds is true, then constrain the parameters in the range provided by MINOS no matter whether that is valid or not (to be improved by checking the validity)\nif igrad is true, then use ForwardDiff.gradient to compute the gradient.\nFor using array parameters, if no user-defined names have been given to the parameters,","category":"page"},{"location":"contour/","page":"Error analysis","title":"Error analysis","text":"paras should be given such that \"x0\" or :x0 for the 1st parameter, \"x1\" or :x1 for the 2nd parameter, ...","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"using IMinuit # hide\nfcn(x) = x[1]^2 + (x[2]-2)^2 + (x[3]-3.2)^4\nm = Minuit(fcn, [1,0,1]; name=[\"a\", \"b\", \"c\"], error=0.1*ones(3), fix_a=true, limit_b=(0, 50) )\nmigrad(m)\nhesse(m)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Here the parameters are collected in an array x which is the argument of fcn(x), and typeof(m) = ArrayFit. In this case, one can use external code to compute the gradient as gradfun(par) = gradient(fcn, par) (the exported gradient function is from ForwardDiff), and include grad = gradfun as a keyword argument.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"If fcn is defined as fcn(a, b), then the starting values need to be set as Minuit(fcn, a = 1, b = 0).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"The asymmetric errors can be obtained by using minos:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using IMinuit # hide\nfcn(x) = x[1]^2 + (x[2]-2)^2 + (x[3]-3.2)^4 # hide\nm = Minuit(fcn, [1,0,1]; name = [\"a\", \"b\", \"c\"], error = 0.1*ones(3), fix_a = true, limit_b = (0, 50) ) # hide\nmigrad(m) # hide\nminos(m)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using IMinuit # hide\nfcn(x) = x[1]^2 + (x[2]-2)^2 + (x[3]-3.2)^4 # hide\nm = Minuit(fcn, [1,0,1]; name = [\"a\", \"b\", \"c\"], error = 0.1*ones(3), fix_a = true, limit_b = (0, 50) ) # hide\nmigrad(m) # hide\nminos(m) # hide\nmigrad(m)","category":"page"}]
}
