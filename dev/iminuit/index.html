<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>iminuit functions · IMinuit.jl</title><link rel="canonical" href="https://fkguo.github.io/IMinuit.jl/iminuit/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">IMinuit.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>iminuit functions</a><ul class="internal"><li><a class="tocitem" href="#Minuit"><span><code>Minuit</code></span></a></li><li><a class="tocitem" href="#migrad,-hesse,-minos"><span><code>migrad</code>, <code>hesse</code>, <code>minos</code></span></a></li><li><a class="tocitem" href="#Some-other-useful-iminuit-functions"><span>Some other useful <code>iminuit</code> functions</span></a></li></ul></li><li><a class="tocitem" href="../example/">Example</a></li><li><a class="tocitem" href="../data/">Data and plot macros</a></li><li><a class="tocitem" href="../modelfit/">chisq and model_fit</a></li><li><a class="tocitem" href="../contour/">Error analysis</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>iminuit functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>iminuit functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fkguo/IMinuit.jl/blob/master/docs/src/iminuit.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-in-iminuit"><a class="docs-heading-anchor" href="#Functions-in-iminuit">Functions in <code>iminuit</code></a><a id="Functions-in-iminuit-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-in-iminuit" title="Permalink"></a></h1><h2 id="Minuit"><a class="docs-heading-anchor" href="#Minuit"><code>Minuit</code></a><a id="Minuit-1"></a><a class="docs-heading-anchor-permalink" href="#Minuit" title="Permalink"></a></h2><pre><code class="language-none">Minuit(fcn; kwds...)::Fit
Minuit(fcn, start; kwds...)::ArrayFit</code></pre><p>Wrapper of the <code>iminuit</code> function <code>Minuit</code>; for more information, refer to the <a href="https://iminuit.readthedocs.io/en/stable/about.html"><code>iminuit</code> manual</a>.</p><ul><li><code>fcn</code> is the function to be optimized.</li><li><code>start</code>: an array/tuple of the starting values of the parameters.</li><li><code>kwds</code> is the list of keywrod arguments of <code>Minuit</code>. </li><li>For the <code>Fit</code> one, <code>fcn</code> takes individual parameters as variables; for the <code>ArrayFit</code> one, <code>fcn</code> takes array parameters.</li></ul><h2 id="migrad,-hesse,-minos"><a class="docs-heading-anchor" href="#migrad,-hesse,-minos"><code>migrad</code>, <code>hesse</code>, <code>minos</code></a><a id="migrad,-hesse,-minos-1"></a><a class="docs-heading-anchor-permalink" href="#migrad,-hesse,-minos" title="Permalink"></a></h2><pre><code class="language-none">migrad, minos, hesse, matrix</code></pre><p>wrappers of <code>iminuit.Minuit.migrad</code>, <code>iminuit.Minuit.minos</code>, <code>iminuit.Minuit.hesse</code>, <code>iminuit.Minuit.matrix</code>.</p><pre><code class="language-none">migrad(f::AbstractFit; ncall = 1000, resume = true, nsplit = 1, precision = nothing)</code></pre><p>minimizing using <code>MIGRAD</code>. Further information (docstring from <code>iminuit</code>) can be found by</p><pre><code class="language-julia">@doc migrad</code></pre><pre><code class="language-none">Minuit.migrad(self, ncall=None, resume=True, int nsplit=1, precision=None)
Run MIGRAD.

        MIGRAD is a robust minimisation algorithm which earned its reputation
        in 40+ years of almost exclusive usage in high-energy physics. How
        MIGRAD works is described in the `MINUIT paper`_.

        **Arguments:**

            * **ncall**: integer or None, optional; (approximate)
              maximum number of call before MIGRAD will stop trying. Default: None
              (indicates to use MIGRAD&#39;s internal heuristic). Using nsplit &gt; 1
              requires ncall &gt; 0. Note: MIGRAD may slightly violate this limit,
              because it checks the condition only after a full iteration of the
              algorithm, which usually performs several function calls.

            * **resume**: boolean indicating whether MIGRAD should resume from
              the previous minimiser attempt(True) or should start from the
              beginning(False). Default True.

            * **nsplit**: split MIGRAD in to *split* runs. Max fcn call
              for each run is ncall/nsplit. MIGRAD stops when it found the
              function minimum to be valid or ncall is reached. This is useful
              for getting progress. However, you need to make sure that
              ncall/nsplit is large enough. Otherwise, MIGRAD will think
              that the minimum is invalid due to exceeding max call
              (ncall/nsplit). Default 1(no split).

            * **precision**: override miniut own&#39;s internal precision.

        **Return:**

            :ref:`function-minimum-sruct`, list of :ref:`minuit-param-struct`
        </code></pre><pre><code class="language-none">hesse(f::AbstractFit; maxcall = 0)</code></pre><p>run <code>HESSE</code> to compute parabolic errors.</p><pre><code class="language-julia">@doc hesse</code></pre><pre><code class="language-none">Minuit.hesse(self, ncall=None, **deprecated_kwargs)
Run HESSE to compute parabolic errors.

        HESSE estimates the covariance matrix by inverting the matrix of
        `second derivatives (Hesse matrix) at the minimum
        &lt;http://en.wikipedia.org/wiki/Hessian_matrix&gt;`_. This covariance
        matrix is valid if your :math:`\chi^2` or likelihood profile looks
        like a hyperparabola around the the minimum. This is usually the case,
        especially when you fit many observations (in the limit of infinite
        samples this is always the case). If you want to know how your
        parameters are correlated, you also need to use HESSE.

        Also see :meth:`minos`, which computes the uncertainties in a
        different way.

        **Arguments:**
            - **ncall**: integer or None, limit the number of calls made by MINOS.
              Default: None (uses an internal heuristic by C++ MINUIT).

        **Returns:**

            list of :ref:`minuit-param-struct`
        </code></pre><pre><code class="language-none">minos(f::AbstractFit; var = nothing, sigma = 1, maxcall = 0)</code></pre><p>run <code>MINOS</code> to compute asymmetric errors taking into account correlation and nonlinearity</p><pre><code class="language-julia">@doc minos</code></pre><pre><code class="language-none">Minuit.minos(self, var=None, sigma=1., ncall=None, **deprecated_kwargs)
Run MINOS to compute asymmetric confidence intervals.

        MINOS uses the profile likelihood method to compute (asymmetric)
        confidence intervals. It scans the negative log-likelihood or
        (equivalently) the least-squares cost function around the minimum
        to construct an asymmetric confidence interval. This interval may
        be more reasonable when a parameter is close to one of its
        parameter limits. As a rule-of-thumb: when the confidence intervals
        computed with HESSE and MINOS differ strongly, the MINOS intervals
        are to be preferred. Otherwise, HESSE intervals are preferred.

        Running MINOS is computationally expensive when there are many
        fit parameters. Effectively, it scans over *var* in small steps
        and runs MIGRAD to minimise the FCN with respect to all other free
        parameters at each point. This is requires many more FCN evaluations
        than running HESSE.

        **Arguments:**

            - **var**: optional variable name to compute the error for.
              If var is not given, MINOS is run for every variable.
            - **sigma**: number of :math:`\sigma` error. Default 1.0.
            - **ncall**: integer or None, limit the number of calls made by MINOS.
              Default: None (uses an internal heuristic by C++ MINUIT).

        **Returns:**

            Dictionary of varname to :ref:`minos-error-struct`, containing
            all up to now computed errors, including the current request.

        </code></pre><p>For a fit <code>f</code>, </p><pre><code class="language-none">args(f::AbstractFit)</code></pre><p>return the parameter values from fit <code>f</code>.</p><pre><code class="language-none">matrix(f::AbstractFit; kws...) </code></pre><p>return error or correlation matrix (set the keyword <code>correlation = true</code>).</p><h2 id="Some-other-useful-iminuit-functions"><a class="docs-heading-anchor" href="#Some-other-useful-iminuit-functions">Some other useful <code>iminuit</code> functions</a><a id="Some-other-useful-iminuit-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Some-other-useful-iminuit-functions" title="Permalink"></a></h2><p>For a fit <code>f</code>, </p><pre><code class="language-none">f.contour(par1, par2; kws)
f.mncontour(par1, par2; kws)
f.draw_contour(par1, par2; kws)
f.draw_mncontour(par1, par2; kws)
f.profile(par1; kws)
f.draw_profile(par1; kws)</code></pre><p>They can also be written as <code>contour(f, par1, par2; kws)</code> etc. Some docstrings from <code>iminuit</code>:</p><pre><code class="language-julia">@doc contour</code></pre><pre><code class="language-none">Minuit.contour(self, x, y, bins=50, bound=2, subtract_min=False, **deprecated_kwargs)
2D contour scan.

        Return the contour of a function scan over **x** and **y**, while keeping
        all other parameters fixed.

        The related :meth:`mncontour` works differently: for new pair of **x** and **y**
        in the scan, it minimises the function with the respect to the other parameters.

        This method is useful to inspect the function near the minimum to detect issues
        (the contours should look smooth). Use :meth:`mncontour` to create confidence
        regions for the parameters. If the fit has only two free parameters, you can
        use this instead of :meth:`mncontour`.

        **Arguments:**

            - **x** variable name for X axis of scan

            - **y** variable name for Y axis of scan

            - **bound**
              If bound is 2x2 array, [[v1min,v1max],[v2min,v2max]].
              If bound is a number, it specifies how many :math:`\sigma`
              symmetrically from minimum (minimum+- bound*:math:`\sigma`).
              Default: 2.

            - **subtract_min** Subtract minimum off from return values. Default False.

        **Returns:**

            x_bins, y_bins, values

            values[y, x] &lt;-- this choice is so that you can pass it
            to through matplotlib contour()

        .. seealso::

            :meth:`mncontour`
            :meth:`mnprofile`

        </code></pre><pre><code class="language-julia">@doc mncontour</code></pre><pre><code class="language-none">Minuit.mncontour(self, x, y, int numpoints=100, sigma=1.0)
Two-dimensional MINOS contour scan.

        This scans over **x** and **y** and minimises all other free
        parameters in each scan point. This works as if **x** and **y** are
        fixed, while the other parameters are minimised by MIGRAD.

        This scan produces a statistical confidence region with the `profile
        likelihood method &lt;https://en.wikipedia.org/wiki/Likelihood_function#Profile_likelihood&gt;`_.
        The contour line represents the values of **x** and **y** where the
        function passes the threshold that corresponds to `sigma` standard
        deviations (note that 1 standard deviations in two dimensions has a
        smaller coverage probability than 68 %).

        The calculation is expensive since it has to run MIGRAD at various
        points.

        **Arguments:**

            - **x** string variable name of the first parameter

            - **y** string variable name of the second parameter

            - **numpoints** number of points on the line to find. Default 20.

            - **sigma** number of sigma for the contour line. Default 1.0.

        **Returns:**

            x MINOS error struct, y MINOS error struct, contour line

            contour line is a list of the form
            [[x1,y1]...[xn,yn]]

        .. seealso::

            :meth:`contour`
            :meth:`mnprofile`

        </code></pre><pre><code class="language-julia">@doc mnprofile</code></pre><pre><code class="language-none">Minuit.mnprofile(self, vname, bins=30, bound=2, subtract_min=False)
Calculate MINOS profile around the specified range.

        Scans over **vname** and minimises FCN over the other parameters in each point.

        **Arguments:**

            * **vname** name of variable to scan

            * **bins** number of scanning bins. Default 30.

            * **bound**
              If bound is tuple, (left, right) scanning bound.
              If bound is\ a number, it specifies how many :math:`\sigma`
              symmetrically from minimum (minimum+- bound* :math:`\sigma`).
              Default 2

            * **subtract_min** subtract_minimum off from return value. This
              makes it easy to label confidence interval. Default False.

        **Returns:**

            bins(center point), value, MIGRAD results
        </code></pre><p>Other <code>iminuit</code> functions can also be used, like <code>f.draw_contour(par1, par2; kws)</code> and <code>f.draw_mncontour(par1, par2; kws)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../example/">Example »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 August 2020 01:20">Monday 10 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
